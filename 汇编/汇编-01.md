###  汇编入门

> 汇编语言和机器语言是一一对应的，每一条机器指令都有与之对应的汇编指令
>
> 汇编语言可以通过编译得到机器语言，机器语言可以通过反汇编得到汇编语言



#### 总线

> 每一个CPU芯片都有许多管脚，这些管脚和总线相连，CPU通过总线跟外部器件进行交互
>
> 总线：一根根导线的集合，每一根导线只能传递高电平(1)和低电平(0)

##### 总线分类

* 地址总线

> 它的宽度决定了CPU的寻址能力
>
> 8086的地址总线宽度是20，所有寻址能力是1M(2的20次方)

* 数据总线

> 它的宽度决定了CPU的单次数据传送量，也就是数据传送速度
>
> 8086的数据总线宽度是16，所以单次最大传递2个字节的数据

* 控制总线

> 它的宽度决定了CPU对其他旗舰的控制能力，能有多少种控制，一般是读和写

#### 内存

* 所有的内存单元都有唯一的地址，叫做物理地址

##### 各类存储器的物理地址情况
* 内存地址空间的大小受CPU地址总线宽度的限制。8086的地址总线宽度为20，可以定位2的20次方的不同的内存单元，内存地址范围(0x00000~0xFFFFF)，内存空间1MB
* 0x00000~0x9FFFF：主存储器，可读可写
* 0xA0000~0xBFFFF：像显存中写入数据
* 0xC0000~0xFFFFF：存储各种硬件/系统信息，只读

#### 8086的寻址方式

> 8086内部只有16位结构，地址总线20位
>
> 8086内部采用2个16位地址合成的方法来生成1个20位的物理地址

* CPU中相关部件提供两个16位的地址：1个是段地址(SA)，1个是偏移地址(EA)
* 地址加法器采用物理地址 =  段地址 *16 + 偏移地址
* CPU可以用不同的段地址和偏移地址形成同一个物理地址
* 段地址又称为起始地址
* 偏移地址为16位，16为地址的寻址能力为64KB，所以一个段的长度最大为64KB

### CPU构成

> 最主要的部件是寄存器，不同的CPU，寄存器的个数、结构是不同的
>
> 8086有14个寄存器，都是16位的寄存器，可以存放2个字节

### 寄存器

#### 通用寄存器

> AX、BX、CX、DX：通常用来存放一般性的数据，称为通用寄存器
>
> H代表高位寄存器
>
> L代表低位寄存器

AX 可分为AH 和 AL

BX 可分为BH 和 BL

CX 可分为CH 和 CL

DX 可分为DH 和 DL

#### 字节和字

> 在汇编的数据存储中，比较常用的2个单位是：

* 字节：**byte**，1个字节由8bit组成，可以存储在8位寄存器中
* 字：**word**，1个字由2个字节组成，2个字节分别称为字的高字节和低字节

#### CS和IP

> CS：CodeSegment，代码段寄存器
>
> IP：指令指针寄存器
>
> 他们指示了CPU当前要读取指令的地址

* 任意时刻，8086CPU都会将CS:IP指向的指令作为下一条需要取出执行的指令



#### jump指令

> 可以通过改变CS、IP的内容来控制CPU执行目标指令
>
> 可以通过jmp指令修改CS、IP的值，统称转移指令

Jmp 2AE3：3，执行后：CS = 2AE3H，IP=0003H，CPU将从2AE33H处读取指令

jmp段地址：偏移地址指令的功能是：用指令中给出的段地址修改CS，偏移地址修改IP

如果想紧紧修改IP的内容，可以形如*jmp 某一合法寄存器*的指令完成

```assembly
jmp ax
指令执行前：ax = 1000H, CS = 2000H， IP = 0003H
执行执行后：ax = 1000H, CS = 2000H， IP = 1000H
```

Jmp 某一合法寄存器指令的功能是：用寄存器中的值修改IP

```assembly
jmp 0100H：直接修改IP的值
```

#### DS

> 数据(DS)段寄存器

```assembly
; 8086中有一个DS段寄存器，通常用来存放访问数据的段地址
mov bx, 1000H
mov ds, bs
mov al, [0]
上面三条指令的作用是：将1000H(1000:0)中的内存数据赋值到al寄存器中
mov al,[address]的意思是将DS:address中的内存数据赋值到al寄存器中
由于al是8位寄存器，所以将一个字节的数据赋值给al寄存器
8086中不支持将数据直接送入段寄存器中，mov ds，1000H是错误的
```

### 大小端

* 大端模式

  > 是指数据的高字节保存在内存的地地址中，而数据的低字节保存在内存的高地址中(高低低高)(Big Endian)

* 小端模式

  > 是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中(高高低低)(Little Endian)

Big Endian：PowerPC,IBM,Sun

Litter Endian：X86, DEC

ARM既可以工作在大端模式，也可以工作在小端模式

### 栈

> 是一种具有特殊的访问方式的存储空间(后进先出：last In Out First， LIFO)

* 8086会将CS作为代码段的段地址，将CS:IP指向的指令作为下一条需要去执行的指令
* 8086会将DS作为数据段的段地址，mov ax, [address]就是去除DS：Address的内存数据放到ax寄存器中
* 8086会将SS作为栈段的段地址，任意时刻，SS:SP指向栈顶元素
* 8086会将PUSH(入栈)和POP(出栈)指令来操作栈段的数据

* 使用一个段存放数据，将它定义为"数据段"
* 使用一个段存放代码，将它定义为"代码段"
* 使用一个段当做栈，将它定义为"栈段"

### 完整汇编程序

```assembly
;关联CS和代码段,code名称可以随便定义
assume cs:code
              
;代码段开始              
code segment       
    mov ax, 1122h
    mov bx, 3344h
    add ax, bx       
    ;正常退出程序的方式
    ;mov ax, 4c00h ;等价于 mov ah, 4ch
    ;int 21h       
           
;代码段结束
code ends
   
;代表程序结束
end
```

### 中断

> 中断是由于软件或者硬件的信号，使得CPU暂停当前的任务，转而去执行另一段子程序。换句话说，在程序运行过程中，系统出现一个必须由CPU立即处理的情况，此时，CPU暂停中止当前程序的执行转而处理这个新情况的过程就叫做中断

##### 中断的分类

* 硬中断(外中断)，由外部设备(比如网卡、硬盘)随机引发的，比如当网卡收到数据包的时候，就会发出一个中断
* 软中断(内中断)，由执行中断指令产生的，可以通过程序控制触发

### call和ret指令

##### call 标号

* 将下一条指令的偏移地址入栈后
* 转到标号处执行指令

##### ret

* 将栈顶的值出栈，赋值给ip

#### 栈平衡

> 函数调用前后的栈顶指针要一致
>
> 栈如果不平衡的结果：栈空间迟早会被用完

* 外平栈
* 内平栈

```assembly
外平栈
 push 1122h
 call sum
 add sp, 4
内平栈
 ret 4
```

### 函数调用流程(内存)

* 1、push 参数
* 2、push 函数的返回地址
* 3、push bp （保留bp之前的值，方便以后恢复）
* 4、mov bp，sp（保留sp之前的值，方便以后恢复）
* 5、sub sp，空间大小（分配空间给局部变量）
* 6、保护可能用到的寄存器
* 7、使用CC（int 3）填充局部变量的空间
* 8、执行业务逻辑
* 9、恢复寄存器之前的值
* 10、mov sp, bp（恢复sp之前的值）
* 11、pop bp（恢复bp之前的值）
* 12、ret （将函数的返回地址出栈，执行下一条指令）
* 13、恢复栈平衡（add sp，参数所占的空间）

### 栈帧

> Stack Frame Layout
>
> 就是一个函数执行的环境
>
> 包括：参数、局部变量、返回地址等
>
> 仅包括在本函数内部执行的所有内存操作