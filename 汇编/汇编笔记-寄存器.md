## 寄存器

**8086CPU**

* 有**14个**寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW
* 所有寄存器都是16位的，可以存放2个字节

#### 通用寄存器

* AX、BX、CX、DX：用来存放**一般性**的数据，被称为通用寄存器，它们四个又可以分为两个可独立的8位寄存器来用
* AX 可分为 AH、AL
* BX 可分为 BH、BL
* CX 可分为 CH、CL
* DX 可分为 DH、DL

#### 寄存器中处理的数据单位

* **字节**： 记 为 byte , 一 个 字 节 由 8 个 b i t 组 成 ， 可 以 存 在 8 位 寄 存 器 中
* **字**：记为 word，一个字由两个字节组成，两个字节分别称为这个字的高位字节和低位字节，1个字可以存在1个16位寄存器中，字的高位字节和低位字节分别存在寄存器的高8位和低8位中

#### 物理地址

* 定义：所有的内存单元构成的 存储空间是 一个 一维的线性空间，每一个内存单元在这个空间中都有唯一的地址
* **CPU**通过地址总线送到存储器的必须是一个内存单元的**物理地址**

* 物理地址 = 段地址 * 16 + 偏移地址

#### 段地址

将若干连续的内存单元看作一个段，用段地址*16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元

段地址x16 必然是16 的倍数，所以一个段的起始地址也 一定是16 的倍数

偏移地址 为16 位，16 位地址的寻址能力为64KB，所以一个段的长度最大为64KB

#### 段寄存器

* 一共有4个段寄存器：CS、DS、SS、ES

##### CS 和 IP

指示**CPU**当前用读取指令的地址，**CS**:代码段寄存器、**IP**：指令指针寄存器

内存单元 = M(CS中的内容)*16 + N(IP中的内容)

**jmp指令**：用于**同时修改CS、IP的内容**

```
jmp 段地址：偏移地址
jmp 2AE3:3 执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令
```

**仅修改IP的内容**

```
jmp 某一合法寄存器：用寄存器中的值修改IP
jmp ax 可以理解为：mov IP，ax
执行前：ax=1000H，CS=2000H，IP=0003H
执行后：ax=1000H，CS=2000H，IP=1000H
jump bx 可以理解为：mov IP，bx
执行前：bx=0B16H，CS=2000H，IP=0003H
执行后：bx=0B16H，CS=2000H，IP=0B16H
```

#### 代码段

* 仅仅是人为的将一段内存当做代码段看待，CPU并不会自动将我们定义的代码段中的指令当作指令 * 执行。CPU 只认被CS:IP 指向的内存单元中的内容为指令。所以，要让CPU 执行我们 放在代码段中的指令，必须要将 CS:IP 指向所定义的代码段中的第 一条指令的首地址

#### 字

使用16位寄存器来存储，高8位存放高位字节，低8位存放低位字节

#### 字单元

字单元：存放一个字型数据(16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中 存放字型数据的低位字节。

将起始地址为N的字单元简称为N地址字单元
