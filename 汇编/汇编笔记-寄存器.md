## 寄存器

**8086CPU**

* 有**14个**寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW
* 所有寄存器都是16位的，可以存放2个字节

#### 通用寄存器

* AX、BX、CX、DX：用来存放**一般性**的数据，被称为通用寄存器，它们四个又可以分为两个可独立的8位寄存器来用
* AX 可分为 AH、AL
* BX 可分为 BH、BL
* CX 可分为 CH、CL
* DX 可分为 DH、DL

#### 寄存器中处理的数据单位

* **字节**： 记 为 byte , 一 个 字 节 由 8 个 b i t 组 成 ， 可 以 存 在 8 位 寄 存 器 中
* **字**：记为 word，一个字由两个字节组成，两个字节分别称为这个字的高位字节和低位字节，1个字可以存在1个16位寄存器中，字的高位字节和低位字节分别存在寄存器的高8位和低8位中

#### 物理地址

* 定义：所有的内存单元构成的 存储空间是 一个 一维的线性空间，每一个内存单元在这个空间中都有唯一的地址
* **CPU**通过地址总线送到存储器的必须是一个内存单元的**物理地址**

* 物理地址 = 段地址 * 16 + 偏移地址

#### 段地址

将若干连续的内存单元看作一个段，用段地址*16定位段的起始地址(基础地址)，用偏移地址定位段中的内存单元

段地址x16 必然是16 的倍数，所以一个段的起始地址也 一定是16 的倍数

偏移地址 为16 位，16 位地址的寻址能力为64KB，所以一个段的长度最大为64KB

#### 段寄存器

* 一共有4个段寄存器：CS、DS、SS、ES

##### CS 和 IP

指示**CPU**当前用读取指令的地址，**CS**:代码段寄存器、**IP**：指令指针寄存器

内存单元 = M(CS中的内容)*16 + N(IP中的内容)

**jmp指令**：用于**同时修改CS、IP的内容**

```
jmp 段地址：偏移地址
jmp 2AE3:3 执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令
```

**仅修改IP的内容**

```
jmp 某一合法寄存器：用寄存器中的值修改IP
jmp ax 可以理解为：mov IP，ax
执行前：ax=1000H，CS=2000H，IP=0003H
执行后：ax=1000H，CS=2000H，IP=1000H
jump bx 可以理解为：mov IP，bx
执行前：bx=0B16H，CS=2000H，IP=0003H
执行后：bx=0B16H，CS=2000H，IP=0B16H
```

#### 代码段

* 仅仅是人为的将一段内存当做代码段看待，CPU并不会自动将我们定义的代码段中的指令当作指令 * 执行。CPU 只认被CS:IP 指向的内存单元中的内容为指令。所以，要让CPU 执行我们 放在代码段中的指令，必须要将 CS:IP 指向所定义的代码段中的第 一条指令的首地址

#### 字

使用16位寄存器来存储，高8位存放高位字节，低8位存放低位字节

#### 字单元

字单元：存放一个字型数据(16位)的内存单元，由**两个地址连续的内存单元**组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

将起始地址为N的字单元简称为：N地址字单元

**DS寄存器**：存放访问数据的段地址

#### 指令

* mov：指令作用

1、将数据直接送入寄存器中，mov 寄存器名称 数据

2、将一个**寄存器中的内容**送入另一个寄存器中，mov 寄存器名称 寄存器名称

3、将一个**内存单元中的内容**送入一个寄存器中(需要明确指出：从哪一个内存单元送到哪一个寄存器中)，(mov 寄存器名称 内存单元地址)，当指令执行时，CPU会自动取DS中的数据为内存单元的段地址

有如下几种形式

```c
mov 寄存器, 数据
mov 寄存器, 寄存器
mov 寄存器, 内存单元
mov 内存单元, 寄存器
mov 段寄存器, 寄存器
```

* add 指令

```
add 寄存器,   数据
add 寄存器,   寄存器
add 寄存器,   内存单元
add 内存单元, 寄存器
```

* sub 指令

```
sub 寄存器,   数据
sub 寄存器,   寄存器
sub 寄存器,   内存单元
sub 内存单元, 寄存器
```

* push 指令

```
push 寄存器;  (将一个寄存器中的数据入栈)
push 段寄存器; (将一个段寄存器中的数据入栈)
push 内存单元 (将一个内存单元的字入栈,栈操作都是以字为单位)，这里的内存单元可以只给出偏移地址，CPU从ds中获取段地址
```

* pop 指令

```
pop 寄存器;	(用一个寄存器接收大出栈的数据)
pop 段寄存器; (用一个段寄存求接收出栈的数据)
pop 内存单元; (用一个内存字单元接收出栈的数据)，这里的内存单元可以只给出偏移地址，CPU从ds中获取段地址
```



#### 栈

栈有两个基本操作：入栈、出栈，该操作被称为 LIFO(last In first Out)

初始状态下**栈**是空的，此时，SP指向栈空间最高地址单元的下一个单元

入栈：将一个新的元素放入栈顶，**栈顶**是从高地址向低地址方向增长

**push ax** 的执行过程由两部完成：

(1)、SP = SP - 2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶

(2)、将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP此时指向新栈顶

```c
// 指令
push ax：表示将寄存器ax中的数据送入栈中，是以字为单位进行
pop ax：表示从栈顶取出数据送入ax，是以字为单位进行
  
```

**SS**：段寄存器，存放栈顶的段地址

**SP**：寄存器，存放偏移地址

任意时刻，**SS:SP**指向栈顶元素，push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址

出栈：从栈顶取出一个元素

**pop ax** 的执行过程由两部分完成：

(1)、将 SS:SP 指向的内存单元处的数据送入ax中

(2)、SP = SP + 2，SS:SP指向当期那栈顶下面的单元，以当前栈顶下面的单元为新的栈顶

#### 总结

对于一个段来说,我们可以

* 用一个段存档数据，将它定位为"数据段"，将它的段地址放在**DS**中，用 mov、add、sub 等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当做数据来访问

* 用一个段存放代码，将它定义为"代码段"，将它的段地址放在**CS**中，将段中第一条指令的偏移地址放在**IP**中，这样CPU就将执行我们定义的代码段中国你的指令

* 用一个段当做栈，将它定义为"栈段"，将它的段地址放在**SS**中，将栈顶单元的偏移地址放在**SP**中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令时，就将我们定义的栈段当做栈空间来用





#### 注意点

**8086CPU** 不支持将数据直接送入**段寄存器**的操作，所以在**8086CPU**中 mov ds， 1000H 指令是非法的！！，要想将1000H 送入ds中，只能用一个寄存器来进行中转，即：先将1000H送入一个一般寄存器中，比如bx，然后再讲bx中的内容宋送入ds中
