## 动态规划（Dynamic Progamming）

#### 动态规划，简称DP

* 是求解最优化问题的一种常见策略

#### 通常的使用套路

1、暴力递归（自顶向下，出现了重叠子问题）

2、记忆力搜索（自顶向下）

3、递推（自底向上）

#### 常规步骤

* 定义状态（状态是原问题、子问题的解）
  * 比如定义dp(i) 的含义
* 设置初始状态
  * 比如设置dp(0)的值
* 确定状态转移方程
  * 比如确定dp(i) 和 dp(i - 1)的关系

#### 概念

* 将复杂的原问题拆解成若干个简单的子问题
* 每个子问题仅仅解决1次，并保存它们的解
* 最后推倒出原问题的解

#### 可以用动态规划解决的问题

* 最优子结构（最优化原理）：通过求解子问题的最优解，可以获得原问题的最优解
* 无后效性
  * 在阶段的状态一旦确定，则此后过程的演变不再受此各状态及决策的影响(未来与过去无关)
  * 在推倒后面阶段的状态时，只关心前面阶段的具体状态值，不关心这个状态是怎么一步步推导出来的

#### 第3题-最长上升子序列(LIS)

* 最长上升子序列



#### 第5题-最长公共子串（Longest Common Substring）

* 子串是连续的子序列
* 解题思路

```java
// 假设2个字符串分别是 str1, str2
i ∈ [1, str1.length]
j ∈ [1, str2.length]
假设dp[i, j]是以str1[i - 1]、str2[j - 1]结尾的最长公共子串长度
dp(i, 0)、dp(0, j) 初始值为0
如果str1[i -1] == str2[j - 1],那么 dp(i, j) = dp(i - 1, j - 1) + 1
如果str1[i - 1] != str2[j - 1]，那么dp(i, j) = 0

最长公共子串的长度是所有do(i, j) 中的最大值max {dp(i, j)}
```

#### 第6题-0-1背包

* 题目：

有n件物品和一个最大承重为 W 的背包，每件物品的重量是 Wi、价值是Vi，在保证总重量不超过 W 的前提下，选择某些物品装入背包，背包的最大总价值是多少？，注意：每个物品只有 1件，也就是每个物品只能选择0 件或者 1件

* 解题思路

```java
假设 values 是价值数组，weights 是重量数组
编号为k的物品，价值是 values[k]，重量是 weights[k]， k∈ [0, n)
                                          
假设 dp(i, j) 是最大承重为 j、有前 i 件物品可选时的最大总价值,i ∈ [0,n), j ∈ [0, W]
dp(i, 0)、dp(0, j) 初始值均为 0
如果 j < weights[i - 1]，那么 dp(i, j) = dp(i- 1， j)
如果 j >= weights[i - 1], 那么dp(i, j) = max { dp(i - 1, j), dp(i - 1, j - weights[i - 1]) + values[i - 1]}
```

#### 第7题-0-1背包

* 题目：

有n件物品和一个最大承重为 W 的背包，每件物品的重量是 Wi、价值是Vi，在保证总重量恰好等于 W 的前提下，选择某些物品装入背包，背包的最大总价值是多少？，注意：每个物品只有 1件，也就是每个物品只能选择0 件或者 1件

* 解题思路

```java
dp(i, j) 初始状态
dp(i, 0) = 0, 总重量恰好为0,最大总价值必然也为0
dp(0, j) = -∞(负无穷), j >= 1，负数在这里代表无法恰好装满
```

