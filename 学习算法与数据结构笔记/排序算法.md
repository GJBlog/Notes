# 排序

## 冒泡排序(Bubble Sort)

> 时间复杂度：O(n^2)

### 执行流程（以升序为例）

1、从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置

* 执行完一轮后，最末尾那个元素就是最大的元素

2、忽略1中曾经找到的最大元素，重复执行步骤1，直到所有元素有序

```java
for (int end = array.length - 1; end > 0; end--) {
  for (int begin = 1; begin <= end; begin++) {
    if (array[begin - 1] > array[begin])  {
      // 交换
      int temp = array[begin - 1];
      array[begin - 1] = array[begin];
      array[begin] = temp;
    }
  }
}
```

冒泡排序优化1

* 如果序列已经完全有序，可以提前终止冒泡排序，添加标志位**sorted**

```java
for (int end = array.length - 1; end > 0; end--) {
  Boolean sorted = true;
  for (int begin = 1; begin <= end; begin++) {
    if (array[begin - 1] > array[begin])  {
      // 交换
      int temp = array[begin - 1];
      array[begin - 1] = array[begin];
      array[begin] = temp;
      sorted = false;
    }
  }
  if (sorted) break;
}
```

冒泡排序优化2

* 如果序列尾部已经局部排序，可以记录最后一次交换的位置，减少比较次数

```java
for (int end = array.length - 1; end > 0; end--) {
			// sortedIndex的初始值在数组完全有序时使用
			int sortedIndex = 1;
			for (int begin = 1; begin <= end; begin++) {
				if (array[begin - 1] > array[begin])  {
					// 交换
					int temp = array[begin - 1];
					array[begin - 1] = array[begin];
					array[begin] = temp;
					sortedIndex = begin;
				}
			}
			end = sortedIndex;
		}
	}
```

#### 排序算法的稳定性(Stability)

* 如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法
* 冒泡排序属于**稳定的排序算法**

### 选择排序

> 选择排序的交换次数要远远小于冒泡排序，平均性能优于冒泡排序
>

执行流程

1、从序列中找出最大的那个元素，然后与最末尾的元素交换位置

* 执行完一轮后，最末尾的那个元素就是最大的元素

2、忽略1中曾经找到的最大元素，重复执行步骤1

```java
for (int end = array.length - 1; end > 0; end--) {
			int maxIndex = 0;
			for (int begin = 1; begin <= end; begin++) {
				// 为了稳定性，需要添加上=的情况
				if (array[begin] >= array[maxIndex]) {
					maxIndex = begin;
				}
			}
			int temp = array[end];
			array[end] = array[maxIndex];
			array[maxIndex] = temp;
		}
```

最好、最坏、平均时间复杂度：**O(n^2)**，空间复杂度：O(1)，属于不稳定排序

### 堆排序(Heap Sort)

> 时间复杂度：nlogn + n 简化为：nlogn

可以认为是对选择排序的一种优化

执行流程

1、对序列进行原地建堆(**heapify**)

2、重复执行以下流程，直到堆的元素数量为1

* 交换堆顶元素与尾元素
* 堆的元素数量减1
* 对0位置进行1次siftDown操作

```java
public class HeapSort<E extends Comparable<E>> extends Sort<E> {
	private int heapSize;
	@Override
	protected void sort() {
		heapSize = array.length;
		// 原地建堆
		for (int i = (heapSize >> 1) - 1; i >= 0; i--) {
			siftDown(i);
		}
		
		while (heapSize > 1) {
			// 交换堆顶元素与尾元素
			// 堆的元素数量减1
			swap(0, --heapSize);
			// 对0位置做siftDown
			siftDown(0);
		}
	}
	
	private void siftDown(int index) {
        int half = heapSize >> 1;
        E element = array[index];
        // 第一个叶子节点的索引 == 非叶子节点的数量
        // index < 第一个叶子节点的索引
        while (index < half) {
            // index的节点有2种情况
            // 1、只有左子节点
            // 2、同时有左右子节点

            // 默认为左子节点跟它进行比较
            int childIndex = (index << 1) + 1;
            E child = array[childIndex];
            // 右子节点
            int rightIndex = childIndex + 1;
            // 选出左右子节点最大的那个
            if (rightIndex < heapSize && cmp(array[rightIndex], child) > 0) {
                child = array[childIndex = rightIndex];
            }
            if (cmp(element, child) >= 0) {
                break;
            }
            // 将子节点存放在index位置
            array[index] = child;
            // 重新设置index
            index = childIndex;
        }
        array[index] = element;
    }
}
```



#### 插入排序(Insertion Sort)

> 非常类似于扑克牌的排序

##### 执行流程

1、在执行的过程中，插入排序会将排序分为2部分

* 头部是已经**排好序**的，尾部是**待排序**的

2、从头部开始扫描每一个元素

* 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

```java
for (int begin = 1; begin < array.length; begin++) {
  int cur = begin;
  while (cur > 0 && cmp(array[cur], array[cur - 1]) < 0) {
    swap(cur, cur - 1);
    cur--;
  }
}
```

逆序对

插入排序的时间复杂度与逆序对的数量成正比关系

逆序对的数量越多，插入排序的时间复杂度越高

逆序对的数量极少时，插入排序的效率特别高

时间复杂度

* 最坏、平均时间复杂度：O(n^2)
* 最好时间复杂度：O(n)
* 空间复杂度：O(1)
* 属于稳定排序

#### 优化

思路：将【交换】转为【挪动】

1、先将待插入的元素备份

2、头部有序数据中比待插入元素大的，都朝尾部方向挪动1个位置

3、将待插入元素放到最终的合适位置

```java
for (int begin = 1; begin < array.length; begin++) {
  int cur = begin;
  E v = array[cur];
  while (cur > 0 && cmp(v, array[cur - 1]) < 0) {
    array[cur] = array[cur - 1];
    cur--;
  }
  array[cur] = v;
}
```

