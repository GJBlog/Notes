### 排序算法

#### 冒泡排序

> 时间复杂度：O(n^2)

* 执行流程
  * 1、从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置

冒泡排序优化1

* 如果序列已经完全有序，可以提前终止冒泡排序

冒泡排序优化2

* 如果序列尾部已经局部排序，可以记录最后一次交换的位置，减少比较次数

#### 排序算法的稳定性(Stability)

* 如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法
* 冒泡排序属于稳定的排序算法

### 选择排序

> 选择排序的交换次数要远远小于冒泡排序，平均性能优于冒泡排序
>
> 最好、最坏、平均时间复杂度：O(n^2)，空间复杂度：O(1)，属于不稳定排序

* 1、从序列中找出最大的那个元素，然后与最末尾的元素交换位置
* 2、执行完一轮后，最末尾的那个元素就是最大的元素
* 3、忽略1中曾经找到的最大元素，重复执行步骤1

### 堆排序(Heap Sort)

> 可以认为是对选择排序的一种优化，
>
> 时间复杂度：nlogn + n 简化为：nlogn

* 1、对序列进行原地建堆(heapify)
* 2、重复执行以下流程，直到堆的元素数量为1
  * A、交换堆顶元素与尾元素
  * B、堆的元素数量减1
  * C、对0位置进行1次siftDown操作

