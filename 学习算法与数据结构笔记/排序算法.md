# 排序算法

## 冒泡排序(Bubble Sort)

> 时间复杂度：O(n^2)

### 执行流程（以升序为例）

1、从头开始比较每一对相邻元素，如果第1个比第2个大，就交换它们的位置

* 执行完一轮后，最末尾那个元素就是最大的元素

2、忽略1中曾经找到的最大元素，重复执行步骤1，直到所有元素有序

```java
for (int end = array.length - 1; end > 0; end--) {
  for (int begin = 1; begin <= end; begin++) {
    if (array[begin - 1] > array[begin])  {
      // 交换
      int temp = array[begin - 1];
      array[begin - 1] = array[begin];
      array[begin] = temp;
    }
  }
}
```

冒泡排序优化1

* 如果序列已经完全有序，可以提前终止冒泡排序，添加标志位**sorted**

```java
for (int end = array.length - 1; end > 0; end--) {
  Boolean sorted = true;
  for (int begin = 1; begin <= end; begin++) {
    if (array[begin - 1] > array[begin])  {
      // 交换
      int temp = array[begin - 1];
      array[begin - 1] = array[begin];
      array[begin] = temp;
      sorted = false;
    }
  }
  if (sorted) break;
}
```

冒泡排序优化2

* 如果序列尾部已经局部排序，可以记录最后一次交换的位置，减少比较次数

```java
for (int end = array.length - 1; end > 0; end--) {
			// sortedIndex的初始值在数组完全有序时使用
			int sortedIndex = 1;
			for (int begin = 1; begin <= end; begin++) {
				if (array[begin - 1] > array[begin])  {
					// 交换
					int temp = array[begin - 1];
					array[begin - 1] = array[begin];
					array[begin] = temp;
					sortedIndex = begin;
				}
			}
			end = sortedIndex;
		}
	}
```

#### 排序算法的稳定性(Stability)

* 如果相等的2个元素，在排序前后的相对位置保持不变，那么这是稳定的排序算法
* 冒泡排序属于**稳定的排序算法**

### 选择排序

> 选择排序的交换次数要远远小于冒泡排序，平均性能优于冒泡排序
>

执行流程

1、从序列中找出最大的那个元素，然后与最末尾的元素交换位置

* 执行完一轮后，最末尾的那个元素就是最大的元素

2、忽略1中曾经找到的最大元素，重复执行步骤1

```java
for (int end = array.length - 1; end > 0; end--) {
			int maxIndex = 0;
			for (int begin = 1; begin <= end; begin++) {
				// 为了稳定性，需要添加上=的情况
				if (array[begin] >= array[maxIndex]) {
					maxIndex = begin;
				}
			}
			int temp = array[end];
			array[end] = array[maxIndex];
			array[maxIndex] = temp;
		}
```

最好、最坏、平均时间复杂度：**O(n^2)**，空间复杂度：O(1)，属于不稳定排序

### 堆排序(Heap Sort)

> 时间复杂度：nlogn + n 简化为：nlogn

可以认为是对选择排序的一种优化

执行流程

1、对序列进行原地建堆(**heapify**)

2、重复执行以下流程，直到堆的元素数量为1

* 交换堆顶元素与尾元素
* 堆的元素数量减1
* 对0位置进行1次siftDown操作

```java
```



#### 插入排序(Insertion Sort)

> 非常类似于扑克牌的排序

##### 执行流程

* 在执行的过程中，插入排序会将排序分为2部分，
  * 头部是已经排好序的，尾部是待排序的
* 从头部开始扫描每一个元素
  * 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

