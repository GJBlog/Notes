## 最短路径（Shortest Path）

* 最短路径是指两顶点之间权值之和最小的路径（有向图、无向图均适用，不能有负权环）
#### 最短路径 - 无权图 
* 无权图相当于是全部权值为1的有权图

#### 最短路径 - 负权边

* 有负权边，但没有负权环时，存在最短路径

#### 最短路径 - 负权环

* 有负权环时，不存在最短路径

#### 典型应用

* 路径规划问题

#### 求解最短路径的3个经典算法

##### 单源最短路径算法

* Dijkstra （迪杰斯特拉算法）
* Bellman-Ford (贝尔曼-福特算法)

##### 多源最短路径算法

* Floyd（弗洛伊德算法）	

#### Dijkstra

* 属于单源最短路径算法，用于计算一个顶点到其他所有顶点的最短路径
* 使用前提：不能有**负权边**
* 时间复杂度：可优化至O(ElogV)，E 是边数量，V是顶点数量

* 松弛操作(Relaxation)：更新两个顶点之间的最短路径，这里一般是指：更新源点到另一个点的最短路径，松弛操作的意义是尝试找出更短的最短路径

#### Bellman-ford

* 也属于单源最短路径算法，支持负权边，还能检测出是否有负权环
* 算法原理：对所有的边进行 V - 1次松弛操作(V 是节点数量)，得到所有可能的最短路径

#### Floyd

* 属于多源最短路径算法，能够求出任意两个顶点之间的最短路径，支持负权边

* 时间复杂度：O(V^3)，效率比执行V次Dijkstra 算法要好(V 是顶点数量)

* 算法原理

  从任意顶点 i 到任意顶点j的最短路径不外乎两种可能,

  1种是：直接从i到j

  2种是：从i经过若千个顶点到j

  * 假设dist(i， j） 为顶点i到顶点j的最短路径的距离

  * 对于每一个顶点k，检查 dist(i, k) + dist(k, j) <dist(i, j) 是否成立

    a) 如果成立，证明从i到k再到j的路径比i直接到j的路径短，设置 dist(, j) = dist(, k t dist(k, j

    b) 当我们遍历完所有结点 k，dist(，）中记录的便是 i 到j的最短路径的距离
