### 10大排序算法

包括：

冒泡排序

选择排序

插入排序

归并排序

快速排序

希尔排序

基数排序

桶排序

计数排序

冒泡、选择、插入、归并、快速、希尔、堆排序属于比较排序（Comparison Sorting）

### 冒泡排序

执行流程(这里以升序为例)

* 1、从头开始比较每一对相邻元素，如果第1个比第2个大，就交换他们的位置

  * 执行完一轮后，最末尾那个元素就是最大的元素

  2、忽略1中曾经找到的最大元素，重复执行步骤1，直到全部元素有序

##### 魔炮排序-优化1

* 如果序列已经完全有序，可以提前终止冒泡排序

##### 冒泡排序-优化2

* 如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数

![image-20220409084816009](/Users/guo/Notes/学习算法与数据结构笔记/images/10大排序_冒泡_优化2.png)

* 最坏、平均时间复杂度：O(n的2次方)
* 最好时间复杂度：O(n)
* 空间复杂度:O(1)

##### 原地算法（In-place Algorithm)

* 所谓原地算法：

1、是指不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入

2、空间复杂度为O(1)的都可以认为是原地算法

* 非原地算法，称为 Not-in-place 或 Out-of-place

3、冒泡算法属于In-place

### 选择排序（Selection Sort）

##### 执行流程
* 1、从序列中找出最大的那个元素，然后与最末尾的元素交换位置
  * 执行完一轮后，最末尾的那个元素就是最大的元素
* 2、忽略1中曾经找到的最大元素，重复执行步骤1

##### 总结

* 选择排序的交换次数要远远小于冒泡排序，平均性能优于冒泡排序
* 最好最坏、平均时间复杂度: O(n的平方)，空间复杂度:O(1)，属于不稳定排序

##### 堆排序(Heap Sort)

> 堆排序是对选择排序的一种优化

执行流程

1、对序列进行原地建堆(Heapify)

2、重复执行以下操作，直到堆的元素数量为1

* 交换堆顶元素与尾元素
* 堆的元素数量减1
* 对0位置进行1次sift Down 操作

##### 插入排序(Insertion Sort)

> 类似于扑克牌的排序

执行流程

1、在执行过程中，插入排序会将序列分为2个部分

* 头部是已经排好序的，尾部是待排序的

2、从头开始扫描每一个元素

* 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

##### 归并排序(Mege Sort)

##### 快速排序(Quick Sort)

* 执行流程

1、从序列中选择一个轴点元素(pivot)

假设每次选择0位置的元素为轴点

2、利用pivot将序列分割成2个子序列

将小于pivot的元素放在pivot前面

将大于pivot的元素放在pivot后面

等于pivot的元素放哪边都可以

3、对子序列进行1、2操作

直到不能再分割(子序列中只剩下1个元素)

##### 希尔排序(Shell Sort)

* 希尔排序把序列看做是一个矩阵，分成m列，逐列进行排序
  * m从某个整数逐渐减为1
  * 当m为1时，整个序列将完全有序
* 希尔排序被称为递增减量排序(Diminishing Increment Sort)
* 矩阵的列数取决于步长序列(step sequence)
  * 比如，

##### 计数排序

##### 基数排序(Radix Sort)

##### 桶排序(Bucket Sort)

执行流程

* 创建一定数量的桶(比如用数组、链表作为桶)
* 按照一定的规则(不同类型的数据，规则不同)，将序列中的元素均匀分配到对应的桶
* 分别对每个桶进行单独排序
* 将所有非空桶的元素合并成有序序列

元素在桶中的索引

* 元素值 * 元素数量

