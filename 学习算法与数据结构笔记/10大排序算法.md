### 10大排序算法

包括：

冒泡排序

选择排序

插入排序

归并排序

快速排序

希尔排序

基数排序

桶排序

计数排序

冒泡、选择、插入、归并、快速、希尔、堆排序属于比较排序（Comparison Sorting）

### 基于比较的排序

#### 冒泡排序

执行流程(这里以升序为例)

* 1、从头开始比较每一对相邻元素，如果第1个比第2个大，就交换他们的位置

  * 执行完一轮后，最末尾那个元素就是最大的元素

  2、忽略1中曾经找到的最大元素，重复执行步骤1，直到全部元素有序

##### 魔炮排序-优化1

* 如果序列已经完全有序，可以提前终止冒泡排序

##### 冒泡排序-优化2

* 如果序列尾部已经局部有序，可以记录最后1次交换的位置，减少比较次数

![image-20220409084816009](/Users/guo/Notes/学习算法与数据结构笔记/images/10大排序_冒泡_优化2.png)

* 最坏、平均时间复杂度：O(n的2次方)
* 最好时间复杂度：O(n)
* 空间复杂度:O(1)

##### 原地算法（In-place Algorithm)

* 所谓原地算法：

1、是指不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入

2、空间复杂度为O(1)的都可以认为是原地算法

* 非原地算法，称为 Not-in-place 或 Out-of-place

3、冒泡算法属于In-place

### 选择排序（Selection Sort）

##### 执行流程
* 1、从序列中找出最大的那个元素，然后与最末尾的元素交换位置
  * 执行完一轮后，最末尾的那个元素就是最大的元素
* 2、忽略1中曾经找到的最大元素，重复执行步骤1

##### 总结

* 选择排序的交换次数要远远小于冒泡排序，平均性能优于冒泡排序
* 最好最坏、平均时间复杂度: O(n的平方)，空间复杂度:O(1)，属于不稳定排序

##### 堆排序(Heap Sort)

> 堆排序是对选择排序的一种优化

执行流程

1、对序列进行原地建堆(Heapify)

2、重复执行以下操作，直到堆的元素数量为1

* 交换堆顶元素与尾元素
* 堆的元素数量减1
* 对0位置进行1次sift Down 操作

##### 插入排序(Insertion Sort)

> 类似于扑克牌的排序

执行流程

1、在执行过程中，插入排序会将序列分为2个部分

* 头部是已经排好序的，尾部是待排序的

2、从头开始扫描每一个元素

* 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

##### 插入排序优化

###### 二分搜索（Binary Search）

* 如果是无序数组，从第1个位置开始遍历搜索，平均时间复杂度：O(n)
* 如果是有序数组，可以使用二分搜索，最坏时间复杂度：O(logn)

二分搜索-思路

* 假设在[begin，end) 范围内搜搜某个元素v，mid = (begin + end) /2
  * 如果v < m，去[begin, mid) 范围内二分搜索
  * 如果 v > m，去[mid + 1, end) 范围内二分搜索
  * 如果 v == m，直接返回 mid



##### 归并排序(Mege Sort)

##### 执行流程

* 不断地将当前序列平均分割成2个子序列
  * 直到不能再分割(序列中只剩1个元素)
* 不断地将2个子序列合并成一个序列
  * 直到最终只剩下1个有序序列

##### 细节

* 在合并的时候，考虑将前一个数组备份一份，再开始合并操作

##### 复杂度

* 由于归并排序总是平均分割子序列，所以最好、最坏、平均时间复杂度都是O(nlogn)
* 空间复杂度是O(n)
* 属于稳定排序

##### 快速排序(Quick Sort)

* 执行流程

1、从序列中选择一个轴点元素(pivot)

假设每次选择0位置的元素为轴点

2、利用pivot将序列分割成2个子序列

将小于pivot的元素放在pivot前面

将大于pivot的元素放在pivot后面

等于pivot的元素放哪边都可以

3、对子序列进行1、2操作

直到不能再分割(子序列中只剩下1个元素)

* 本质
  * 逐渐将每一个元素都转换成轴点元素



##### 希尔排序(Shell Sort)

* 希尔排序把序列看做是一个矩阵，分成m列，逐列进行排序
  * m从某个整数逐渐减为1
  * 当m为1时，整个序列将完全有序
* 希尔排序被称为递增减量排序(Diminishing Increment Sort)
* 矩阵的列数取决于步长序列(step sequence)
* 希尔排序底层一般使用插入排序对每一列进行排序，也有很多资料认为希尔排序是插入排序的改进版

### 非基于比较的排序

##### 1、计数排序 (Counting Sort)

> 适合对一定范围内的整数排序

**核心思想**

* 统计每个整数在序列中出现的次数，进而推导出每个整数在有序序列中的索引

**复杂度**

* 最好、最坏、平均的时间复杂度：O(n + k)，空间复杂度：O(n + k)
* k是整数的取值范围
* 属于稳定排序

如果自定义对象可以提供用以排序的整数类型，依然可以使用计数排序



##### 基数排序(Radix Sort)

> 基数排序非常适合用于整数排序(尤其是非负整数)

执行流程：依次对个位数、十位数、百位数、千位数、万位数...进行排序(从低位到高位)

个位数、十位数、百位数的取值范围都是固定的0~9，可以使用计数排序对它们进行排序

**复杂度**

* 最好、最坏、平均时间复杂度：O(d * (n + k))，d是最大值的位数，k是进制，属于稳定排序
* 空间复杂度：O(n + k)，k是进制

##### 桶排序(Bucket Sort)

**执行流程**

* 创建一定数量的桶(比如用数组、链表作为桶)
* 按照一定的规则(不同类型的数据，规则不同)，将序列中的元素均匀分配到对应的桶
* 分别对每个桶进行单独排序
* 将所有非空桶的元素合并成有序序列

元素在桶中的索引

* 元素值 * 元素数量

