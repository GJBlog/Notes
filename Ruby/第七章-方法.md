## 方法

----

> 方法是由对象定义且与该对象相关的操作
>
> 在Ruby中，对象的所有操作都被封装成方法

#### 一、方法调用

1、简单的方法调用

```ruby
对象.方法名(参数1，参数2，参数...n)
```

2、带块的方法调用

* 方法本身可以与伴随块一起被调用。这种与块一起被调用的方法称为带块的方法，**do ~ end** 被称为块

```ruby
# 第一种写法
对象.方法名(参数, .....) do |变量1, 变量2, ....|
    块内容
end
```

```ruby
# 第二种写法
对象.方法名(参数, .....){|变量1, 变量2, ....|
    块内容
}
```

3、运算符形式的方法调用

在Ruby中,如下的运算符也被称为方法调用

```ruby
obj + arg1

obj =~ arg1

-obj

!obj

obj[arg1]

obj[arg1] = arg2
```

#### 二、方法分类
##### 1、实例方法

* 以对象(实例)为接收者的方法称为实例方法

```ruby
p "10, 20, 30, 40".split(",")    #=> ["10", "20", "30", "40"]
```

##### 2、类方法

* 接收者不是对象而是类本身时的方法，称之为类方法
* 时候用类名来调用
* 调用类方法时，可以使用 `::` 代替 `.`，表达的意思相同

```ruby
File.rename(oldname, newname)    # 修改文件名
```

##### 3、函数式方法

* 没有接收者的方法，我们称之为函数式方法
* 虽说是没有接收者，但并不表示该方法就真的没有可作为接收者的对象，只是在函数式方法这个特殊情况下，可以省略接收者而已
* 函数式方法的执行结果，不会根据接收者的状态而发生变化。即不需要接收者的方法就是函数式方法。

```ruby
print "hello!"    # 在命令行输出字符串
sleep(10)         # 在指定的时间内睡眠，终止程序
```

##### 方法文档

* 在帮助文档中标记实例方法

```ruby
类名#方法名
```

* 在帮助文档中标记类方法

```ruby
类名.方法名
```

```ruby
类名::方法名
```

#### 三、定义方法

1、定义语法如下

```ruby
def 方法名(参数1, 参数2,...)
  希望执行的处理
end
```

* 方法名可由英文字母、数字、下划线组成，不能以数字开头

```ruby
def hello(name)
  puts "Hello, #{name}."
end
hello("Ruby")
```

2、指定参数默认值

* 参数的默认值，是指在没有指定参数的情况下调用方法时，程序默认使用的值，定义方法时，形式为：参数名=值
* 方法有多个参数时，从参数列表的右边开始依次指定默认值
* 只省略左边的参数或者中间的某个参数是不行的
* 此处参数被称为普通参数

```ruby
def hello(name="Ruby")
  puts "Hello, #{name}."
end
hello()         # 省略参数的调用
hello("Newbie") # 指定参数的调用
```

3、方法返回值

使用**return**来指定方法的返回值

* 可以省略 `return` 语句，这时方法的最后一个表达式的结果就会成为方法的返回值

* 如果省略 `return` 的参数，程序则返回 `nil`。方法的目的是程序处理，所以 Ruby 允许没有返回值的方法

**4**、定义带块的方法

* `yield` 是定义带块的方法时最重要的关键字。调用方法时通过块传进来的处理会在 `yield` 定义的地方执行。

```ruby
def myloop
  while true
    yield               # 执行块
  end
end

num = 1                 # 初始化num
myloop do
  puts "num is #{num}"  # 输出num
  break if num > 100    # num 超过 100 时跳出循环
  num *= 2              # num 乘2
end
```

5、参数不确定的方法

通过`*` 变量名”的形式来定义参数个数不确定的方法，Ruby 就可以把所有参数封装为数组，供方法内部使用

```ruby
def foo(*args)
  args
end
```

* 如果需要至少一个参数方法，可以这样定义

```ruby
def meth(arg, *agrs) 
  [arg, args]
end

p meth(1) #=> [1, []]
p meth(1, 2, 3) #=> [1, [2, 3]]
```

* 所有不确定的参数都被作为数组赋值给变量 `args`。“`*` 变量名”这种形式的参数，只能在方法定义的参数列表中出现一次

```ruby
def a(a, *b, c) [a, b, c]
end

p a(1, 2, 3, 4, 5) #=> [1, [2, 3, 4], 5] p a(1, 2) #=> [1, [], 2]
```

6、**关键字**参数

在目前为止介绍过的方法定义中，我们都需要定义调用方法时的参数个数以及调用顺序。而使用关键字参数，就可以将参数名与参数值成对地传给方法内部使用

```ruby
def 方法名(参数1: 参数1的值, 参数2: 参数2的值,.....)
	希望执行的处理
end
```

```ruby
def area2(x: 0, y: 0, z: 0)
  xy = x * y
  yz = y * z
  zx = z * x
  (xy + yz + zx ) * 2
end
```

* 使用“参数名 : 值”这样的形式还可以指定参数的默认值
* 为了避免调用方法时因指定了未定义的参数而报错，我们可以使用“`**` 变量名”的形式来 接收未定义的参数。下面这个例子的方法中，除了关键字参数 `x`、`y`、`z` 外，还定义了 `**arg` 参数。参数 `arg` 会把参数列表以外的关键字参数以散列对象的形式保存

```ruby
def meth(x: 0, y: 0, z: 0, **args) [x, y, z, args]
end

p meth(z: 4, y: 3, x: 2) #=> [2, 3, 4, {}]
p meth(x: 2, z: 3, v: 4, w: 5) #=> [2, 0, 3, {:v=>4, :w=>5}]
```

* 此处参数被称为关键字参数

7、用散列传递参数

* 用 { ~ } 这样的形式来表示散列的字面量(literal)。将散列的字面量作为参数传递给方法时可以省略 {}

```ruby
def foo(arg)
  arg
end

p foo({"a"=>1, "b"=>2}) p foo("a"=>1, "b"=>2)
p foo(a: 1, b:2)
#=> {"a"=>1, "b"=>2} #=> {"a"=>1, "b"=>2} #=> {:a=>1, :b=>2}
```

* 虽然有多个参数，但只将散列作为最后一个参数传递给方法时，可以使用下面的写法:

```ruby
def bar(arg1, arg2) [arg1, arg2]
end
 
p bar(100, {"a"=>1, "b"=>2}) p bar(100, "a"=>1, "b"=>2)
p bar(100, a: 1, b: 2)
#=> [100, {"a"=>1, "b"=>2}] #=> [100, {"a"=>1, "b"=>2}] #=> [100, {:a=>1, :b=>2}]
```

##### 注意点

* 调用方法时，方法的**()**可以省略
* 使用**do~end**时，可以省略把参数列表括起来**()**,使用{ ～ }` 时，只有在没有参数的时候才可以省略 `()
