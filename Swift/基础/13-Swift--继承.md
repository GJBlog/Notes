# 继承

## 1、子类

* 指明某个类的超类，将超类名写在子类名的后面，用冒号分隔
* 默认情况下，子类继承超类的所有特性

```swift
class SomeClass: SomeSuperclass {
    // 这里是子类的定义
}
```

## 2、重写

* 所谓重写：子类为继承来的实例方法、类型方法、实力属性、类型属性、下标提供自己的实现
* 如果要重写某个特性，需要在重写定义的前面加上```override```关键字
* 子类中可以通过```super```访问超类的方法、属性、下标
    * 在方法 someMethod() 的重写实现中，可以通过 super.someMethod() 来调用超类版本的 someMethod() 方法
    * 在属性 someProperty 的 getter 或 setter 的重写实现中，可以通过 super.someProperty 来访问超类版本的 someProperty 属性
    * 在下标的重写实现中，可以通过 super[someIndex] 来访问超类版本中的相同下标
* 可以提供定制的 getter（或 setter）来重写任何一个继承来的属性，无论这个属性是存储型还是计算型属性
* 可以再子类中为只读属性重写为一个读写属性，只需要在重写版本的属性里提供getter和setter，**不可以**将一个继承来的读写属性重写为一个只读属性
* 可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，无论被继承属性原本是如何实现的，当其属性值发生改变时，你就会被通知到

```swift
class Train: Vehicle {
    override func makeNoise() {
        print("Choo Choo")
    }
}
```
## 3、中止重写

* 可以通过把方法、属性、下标标记为```final```来防止它们被重写，只需要在声明关键字前加上```final```修饰符即可
* 在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final
* 可以通过在关键字```class```前添加```final```修饰符（final class）来将整个类标记为 final 。这样的类是不可被继承的

## 4、注意点

* 能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性
* 通过在方法名称上添加```@discardableResult```,可以忽略返回值，不产生编译警告
* 如果在重写的属性中体提供了setter，那么就一定要提供getter
* 不可以为继承来的 常量存储型属性 或继承来的 只读计算型属性 添加属性观察器
* 不可以同时提供重写的setter和重写的属性观察器,如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了
* 被class修饰的类型方法、下标，允许被子类重写
* 被static修饰的类型方法、下标，不允许被子类重写
* 子类重写后的属性权限要大于等于父类的属性权限
  * 如果父类属性是只读，则子类可以是只读也可是可读可写
  * 如果父类属性是可读可写，则子类必须是可读可写

