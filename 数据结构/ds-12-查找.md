### 查找

* 概念

    * **查找表**：是由同一类型的数据元素(或记录)构成的集合
    * **关键字(key)**：是数据元素中某个数据项的值，又称为键值，用它标识一个数据元素，也可以标识一个记录的某个数据项(字段),称为关键码
    * **主关键字(Primary Key)**：若此关键字可以唯一标识一个记录，则称此关键字为主关键字。主关键字所在的数据项称为主关键码
    * **次关键字(Secondary Key)**：可以标识多个数据元素(或记录)的关键字，称为次关键字，也可以理解为是不以唯一标识一个数据元素(或记录)的关键字，它对应的数据项就是次关键字
    
* 查找表按照操作分为2种：静态查找表、动态查找表
* 顺序表查找：
    - 顺序查找（Sequential Search）又叫线性查找，是最基本的查找技术
* 有序表查找：
    - 折半查找（Binary Search）技术，又称为二分查找。**使用的前提是**：线性表中的记录必须是关键码有序(通常从小到大有序)，线性表必须采用顺序存储。**基本思想**：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。

    - 插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式(key-a[low])/(a[high]-a[low])。

    - 斐波那契查找

  * 线性索引查找

        * 稠密索引
        * 分块索引：对数据集进行分块，对应每块有一个索引项
            - 块内无序
            - 块间有序
        * 倒排索引

* 二叉排序树（Binary Sort Tree）：又称为二叉查找树，构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。它或者是一颗空树，或者是具有下列性质的二叉树：
    
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉排序树

* 平衡二叉树(AVL树)

    - 平衡二叉树（Self-Balancing Binary SearchTree或Height-Balanced Binary Search Tree），是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。
    - 二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF（Balance Factor）
    - 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树。当最小不平衡子树根结点的平衡因子BF是大于1时，就右旋，小于-1时就左旋
    
* 多路查找树(B树, muitl-way search tree)

    - 其每一个结点的孩子数可以多余两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系
    - 分类：
        - 2-3树：其中的每一个结点都具有两个孩子(2结点)或者三个孩子(3结点)，一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。

        - 2-3-4树：是对2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。

        - B树：是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶（order）。B树的数据结构就是为内外存的数据交互准备的。

        
        - B+树

 * 散列表查找(哈希表)
 
    - 散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。对应关系f称为散列函数，又称为哈希(Hash)函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表(Hash table)，关键字对应的记录存储位置称为散列地址。

    - 散列表查找

        - 在存储时，通过散列函数计算出记录的散列地址，并按此散列地址存储该记录。
        - 当查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址来访问该记录。

    - 散列函数构造方法

        - 直接定址法
            - **概念**：取关键字的某个线性函数值为散列地址
                
                    f(key) = a*key + b (a、b为常数)。
                
            - **特点**：简单、均匀，不会产生冲突，需要事先知道关键字的分布情况，适合查找表较小且连续的情况

        
        - 数字分析法
            - **特点**：数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。
        
        - 平方取中法
            - **特点**：比较适合于不知道关键字的分布，而位数又不是很大的情况。
        
        - 折叠法
            - **特点**：是将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。事先不需要知道关键字的分布，适合关键字位数较多的情况
        
        - 除留余数法
            - **特点**：为最常用的构造散列函数方法。对于散列表长为m的散列函数公式为：f(key)=key mod p(p≤m)mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。很显然，本方法的关键就在于选择合适的p，p如果选得不好，就可能会容易产生同义词。若散列表表长为m，通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数

        - 随机数法
            - **特点**：选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key)=random(key)。这里random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。
        

    - 处理散列函数冲突
        - 开放定址法：又被称为线性探测法。所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
          **它的公式是**：
          
            ```fi(key)=(f(key)+di)MOD m(di=1,2,3,......,m-1)```
        
        - 二次探测法：

        ```fi(key)=(f(key)+di)MOD m(di=12,-12,22,-22,...,q2,-q2,q≤m/2)```

        - 随机探测法：在冲突时，对于位移量di采用随机函数计算得到

        - 再散列函数法：事先准备多个散列函数，```“fi(key)=RHi(key)(i=1,2,...,k)```，RHi就是不同的散列函数，你可以把我们前面说的什么除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。

        - 链地址法：将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。使用此种方法不存在冲突问题，无论有多少个冲突，都只是在当前位置给单链表添加结点

        - 公共溢出区法：为所有冲突的关键字建立了一个公共的溢出区来存放

    - 散列表查找
        -
         


