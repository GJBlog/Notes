## 排序

### 概念

* 假设含有n个记录的序列为{r1,r2,......,rn}，其相应的关键字分别为{k1,k2,......,kn}，需确定1,2,......,n的一种排列p1,p2,......,pn，使其相应的关键字满足kp1≤kp2≤......≤kpn（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列{rp1,rp2,......,rpn}，这样的操作就称为排序


### 排序稳定性

* 假设ki=kj(1≤i≤n,1≤j≤n,i≠j），且在排序前的序列中ri领先于rj（即i<j）。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的
* 若可能使得排序后的序列中rj领先ri，则称所用的排序方法是不稳定的。Books. 

### 排序分类：

#### 内排序

* 在排序整个过程中，待排序的所有记录全部被放置在内存中。
* 排序算法性能因素

    - 时间性能
    - 辅助空间
    - 算法的复杂性

* 依据排序过程中借助的主要操作分类

    * 插入排序
    * 交换排序
    * 选择排序
    * 归并排序
        
#### 外排序

* 由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

#### 排序算法

* 按照算法复杂度分为

    * 简单算法：冒泡排序、简单选择排序、直接插入排序
    * 改进算法：希尔排序、堆排序、归并排序、快速排序


#### 冒泡排序

```c

// 第一种
void BubbleSort0(SqList *L)
{
    int i, j;
    for (i = 1; i < L->length; i++)
    {
        for (j = i + 1; j <= L->length; j++)
        {
            if (L->r[i] > L->r[j])
            {
                /* 交换L->r[i]与L->r[j]的值 */
                swap(L, i, j);
            }
        }
    }
}

// 第二种
void BubbleSort(SqList *L)
{
    int i, j;
    for (i = 1; i < L->length; i++)
    {
        /* 注意j是从后往前循环 */
        for (j = L->length - 1; j >= i;j--)
        {
            /* 若前者大于后者(注意这里与上一算法差异) */
            if (L->r[j] > L->r[j + 1])
            {
                /* 交换L->r[j]与L->r[j+1]的值 */
                swap(L, j, j + 1);
            }
        }
    }
}

// 第三种
void BubbleSort2(SqList *L)
{
    int i, j;
    /* flag用来作为标记 */
    BOOL flag = true;
    /* 若flag为true说明有过数据交换，否则停止循环 */
    for (i = 1; i < L->length && flag; i++)
    {
        /* 初始为false */
        flag = FALSE;
        for (j = L->length - 1; j >= i; j--)
        {
            if (L->r[j] > L->r[j + 1])
            {
                /* 交换L->r[j]与L->r[j+1]的值 */
                swap(L, j, j + 1);
                /* 如果有数据交换，则flag为true */
                flag = true;
            }
        }
    }
}

```
* 时间复杂度：O(n²)

#### 简单选择排序

```c
/* 对顺序表L作简单选择排序 */
void SelectSort(SqList *L)
{
    int i, j, min;
    for (i = 1; i < L->length; i++)
    {
        /* 将当前下标定义为最小值下标 */
        min = i;
        /* 循环之后的数据 */
        for (j = i + 1; j <= L->length; j++)
            5
        {
            /* 如果有小于当前最小值的关键字 */
            if (L->r[min] > L->r[j])
            /* 将此关键字的下标赋值给min */
                min = j;
        }
        /* 若min不等于i，说明找到最小值，交换 */
        if (i != min)
        /* 交换L->r[i]与L->r[min]的值 */
            swap(L, i, min);
    }
}

```
* 时间复杂度：O(n²)
* 性能上略优于冒泡算法


### 直接插入排序

* 直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。顾名思义，从名称上也可以知道它是一种插入排序的方法。我们来看直接插入排序法的代码。

```c
“/* 对顺序表L作直接插入排序 */
void InsertSort(SqList *L)
{
    int i, j;
    for (i = 2; i <= L->length; i++)
    {
        /* 需将L->r[i]插入有序子表 */
        if (L->r[i] < L->r[i - 1])        
        {
            /* 设置哨兵 */
            L->r[0] = L->r[i];            
            for (j = i - 1; L->r[j] > L->r[0]; j--)
                /* 记录后移 */
                L->r[j + 1] = L->r[j];    
            /* 插入到正确位置 */
            L->r[j + 1] = L->r[0];        
        }
    }
}
```
* 时间复杂度：O(n²)，且性能比冒泡和简单选择排序性能要好

### 希尔排序

* 原理：

```c
/* 对顺序表L作希尔排序 */
void ShellSort(SqList *L)
{
    int i, j;
    int increment = L->length;
    do
    {
        /* 增量序列 */
        increment = increment / 3 + 1;                
        for (i = increment + 1; i <= L->length; i++)
        {
            if (L->r[i] < L->r[i - increment])
            {                                         
                /* 需将L->r[i]插入有序增量子表 */
                /* 暂存在L->r[0] */
                L->r[0] = L->r[i];                    
                for (j = i - increment; j > 0 && 
                     L->r[0] < L->r[j]; j -= increment)
                    /* 记录后移，查找插入位置 */
                    L->r[j + increment] = L->r[j];    
                /* 插入 */
                L->r[j + increment] = L->r[0];        
            }
        }
    }
    while (increment > 1);
}
```
* 时间复杂度：O(n二分之三次方),且性能比前面算法好

### 堆排序

* 概念：是对简单选择排序的一种改进
* 堆结构：是具有如下性质的完全二叉树

    * 每个结点的值都大于或等于其左右孩子结点的值称为大顶堆
    * 每个结点的值都小于或等于其左右孩子结点的值称为小顶堆

```c
/* 对顺序表L进行堆排序 */
void HeapSort(SqList *L)
{
    int i;
    /* 把L中的r构建成一个大顶堆 */
    for (i = L->length / 2; i > 0; i--)    
        HeapAdjust(L, i, L->length);
    for (i = L->length; i > 1; i--)
    {
        /* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */
        swap(L, 1, i);                     
        /* 将L->r[1..i-1]重新调整为大顶堆 */
        HeapAdjust(L, 1, i - 1);           
    }
}

/* 已知L->r[s..m]中记录的关键字除L->r[s]之外
    均满足堆的定义 */
/* 本函数调整L->r[s]的关键字，使L->r[s..m]成
   为一个大顶堆 */
void HeapAdjust(SqList *L,int s,int m)
{
    int temp, j;
    temp = L->r[s];
    /* 沿关键字较大的孩子结点向下筛选 */
    for (j = 2 * s; j <= m; j *= 2)    
    {
        if (j < m && L->r[j] < L->r[j + 1])
            /* j为关键字中较大的记录的下标 */
            ++j;                       
        if (temp >= L->r[j])
            /* rc应插入在位置s上 */
            break;                     
        L->r[s] = L->r[j];
        s = j;
    }
    /* 插入 */
    L->r[s] = temp;                    
}

```

* 时间复杂度：O(nlogn)

### 归并排序

* 将两个或两个以上的有序表组合成一个新的有序表
* 原理：利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到|n/2|（|x|表示不小于x的最小整数）个长度为2或1的有序子序列；再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止，这种排序方法称为2路归并排序

```c
/* 对顺序表L作归并排序 */
void MergeSort(SqList *L)
{
    MSort(L->r, L->r, 1, L->length);
} 

/* 将SR[s..t]归并排序为TR1[s..t] */
void MSort(int SR[], int TR1[], int s, int t)
{
    int m;
    int TR2[MAXSIZE + 1];
    if (s == t)
        TR1[s] = SR[s];
    else
    {
        /* 将SR[s..t]平分为SR[s..m]和SR[m+1..t] */
        m = (s + t) / 2;             
        /* 递归将SR[s..m]归并为有序的TR2[s..m] */
        MSort(SR, TR2, s, m);        
        /* 递归将SR[m+1..t]归并为有序TR2[m+1..t] */
        MSort(SR, TR2, m + 1, t);   
        /* 将TR2[s..m]和TR2[m+1..t] */
        /* 归并到TR1[s..t] */
        Merge(TR2,TR1, s, m, t);     
    }
}

/* 将有序的SR[i..m]和SR[m+1..n]归并为有序的
   TR[i..n] */
void Merge(int SR[], int TR[], int i, int m, int n)
{
    int j, k, l;
    /* 将SR中记录由小到大归并入TR */
    for (j = m + 1, k = i; i <= m && j <= n; k++)    
    {
        if (SR[i] < SR[j])
            TR[k] = SR[i++];
        else
            TR[k] = SR[j++];
    }
    if (i <= m)
    {
        for (l = 0; l <= m - i; l++)
            /* 将剩余的SR[i..m]复制到TR */
            TR[k + l]=SR[i + l];                     
    }
    if (j<=n)
    {
        for (l = 0; l <= n - j; l++)
            /* 将剩余的SR[j..n]复制到TR */
            TR[k + l] = SR[j + l];                   
    }
}

```
* 时间复杂度：O(nlogn)，归并排序是一种比较占用内存，但却效率高且稳定的算法


### 快速排序

* 原理：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小
* 枢轴(pivot)：先选取当中的一个关键字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴（pivot）。
* 时间复杂度：在最优的情况下，快速排序算法的时间复杂度为O(nlogn)

* 快速排序优化

    * 优化选取枢轴：随机选取枢轴法、三数取中法、九数取中法
    * 优化不必要交换
    * 优化小数组时的排序方案
    * 优化递归操作
    * 了不起的排序算法

### 排序总结

* 希尔排序相当于直接插入排序的升级，属于插入排序类
* 堆排序相当于简单选择排序的升级，属于选择排序类
* 快速排序是最慢的冒泡排序的升级，属于交换排序类
* 综合来说，优化后的快速排序是性能最好的算法


