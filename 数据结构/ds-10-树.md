### 树(Tree)

#### 概念

* 是n(n >= 0)个结点的有限集。
* 空树
    * n = 0 称为空树。
* 根结点
    * 有且仅有一个特定的称为根(Root)的结点
* 子树
    * n＞1时，其余结点可分为m（m＞0）个互不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。
* n > 0时，根结点是唯一的，不可能存在多个根节点，即数据结构中的树只有一个根结点。
* m > 0时，子数的个数没有限制，但它们一定是互不相交的。
* 结点分类
    * 树的结点包含一个数据元素及若干指向其子数的分支。结点拥有的子树数称为结点的度(Degree)。
    * 度为0的结点称为叶节点(Leaf)或终端结点。
    * 度不为0的结点称为分支结点或非终端结点。
    * 除了根节点之外，分支结点也称为内部结点。
    * 树的度是树内各结点的度的最大值。

* 结点关系
    * 结点的子树的根称为结点的孩子(Child)。
    * 该结点称为孩子的双亲(Parent)。
    * 同一个双亲的孩子之间互称兄弟(Sibling)。
    * 结点的祖先是从根到该结点所经分支上的所有结点。
    * 以某结点为根的子树中的任一结点都称为该结点的子孙。
    * 结点的层次(Level)：是从根开始定义起，根为第一层，根的孩子为第二层。
    * 若某结点在第l层，则其子树就在第l+1层。其双亲在同一层的结点互为堂兄弟。
    * 树中结点的最大层次称为树的深度(Depth)或高度。
    * 如果将树中结点的各子树看成从左到右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。
* 森林
    * 是m(>=0)颗互不相交的树的集合。对于树中的每一个结点而言，其子树的集合即为森林。
* 特点
    * 根结点：无双亲，唯一
    * 叶节点：无孩子，可以多个
    * 中间结点：一个双亲多个孩子

* 树的结构存储
    * 双亲表示法
        * 以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。
    * 孩子表示法
        * 多重链表表示法
    * 孩子兄弟表示法
       
#### 二叉树
       
* 特点
    * 每个结点最多有两棵树，所以二叉树中不存在度大于2的结点。
    * 左子树和右子树是有顺序的，次序不能颠倒。
    * 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树
* 基本形态
    * 空二叉树
    * 只有一个根结点
    * 根结点只有左子树
    * 根节点只有右子树
    * 根节点既有左子树，右有右子树

* 特殊二叉树
    * 斜树
        * 所有结点都只有左子树的二叉树叫做左斜树
        * 所有结点都只有右子树的二叉树叫做右斜树
    * 满二叉树
        * 所有分支结点都存在左子树和右子树
        * 所有叶子都在同一层上
        * 特点
            * 叶子只能出现在最下一层
            * 非叶子结点的度一定是2
            * 在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多
    * 完全二叉树
        * 对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树
        * 满二叉树一定是一颗完全二叉树，但是完全二叉树不一定是满的
        * 特点
            * 叶子结点只能出现在最下两层
            * 最下层的叶子一定集中在左部连续位置
            * 倒数二层，如果有叶子结点，一定都是在右部连续位置
            * 如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况
            * 同样结点树的二叉树，完全二叉树的深度最小
* 性质
    * 在二叉树的第i层上至多有2的(i-1)次方个结点(i>=1)
    * 深度为k的二叉树至多有2的k次方-1个结点(k>=1)
    * 对于任何一颗二叉树T，如果其终端结点树为N0,度为2的结点数为N2,则N0 = N2 + 1
    * 具有n个结点的完全二叉树的深度为|log2N + 1|(|x|表示不大于x的最大整数)
    * 如果对一棵有n个结点的完全二叉树（其深度为）的结点按层序编号（从第1层到第层，每层从左到右），对任一结点i（1≤i≤n）有
        * 1．如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点。
        * 2．如果2i>n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。
        * 3．如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1。
    * 已知前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树
    * 已知后续遍历序列和中序遍历序列，可以唯一确定一颗二叉树

* 存储结构
    * 顺序存储结构：用一维数组来存储二叉树的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。一般只用于完全二叉树。
    * 二叉链表：一个数据域 + 两个指针域
*  遍历二叉树
    *  原理：从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次
    *  遍历方法
        *  前序遍历：若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。
        *  中序遍历：若二叉树为空，则空操作返回，否则从根节点开始(并不是先访问根结点)，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。
        *  后序遍历：若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。
        *  层序遍历：若二叉树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按照从左到右的顺序对结点逐个访问。

#### 线索二叉树
* 概念
    * 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。
* 结点：lchild ltag data rtag rchild
    * ltag：为0时指向该结点的左孩子，为1时指向该结点的前驱
    * rtag：为0时指向该结点的右孩子，为1时指向该结点的后继

#### 树转为二叉树
* 步骤
    * 1.加线。在所有兄弟结点之间加一条连线。 
    * 2.去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。 
    * 3.层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。

#### 森林转为二叉树
* 步骤
    * 1.把每个树转换为二叉树。 
    * 2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。
    
#### 二叉树=>树
* 步骤
    * 1.加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。 
    * 2.去线。删除原二叉树中所有结点与其右孩子结点的连线。 
    * 3.层次调整。使之结构层次分明。

#### 二叉树=>森林 
* 步骤
    * 判断一棵二叉树能够转换成一棵树还是森林，只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树
    
#### 树遍历
* 步骤
    * 1、一种是先根遍历树，即先访问树的根节点，然后依次先根遍历根的每颗子树
    * 2、一种是后跟遍历，即限一次后跟遍历每颗子树，然后再访问根节点

#### 森林遍历
* 步骤
    * 1、前序遍历：先访问森立中第一棵树的根节点，然后再依次先根遍历根的每颗子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林
    * 2、后序遍历：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林

森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同
以二叉链表做树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法实现

#### 赫夫曼树
* 概念
    * 带权路径长度WPL最小的二叉树称为赫夫曼树(最优二叉树)
* 权：树结点间的边相关的数叫做权(weight)
* 路径长度：路径上的分支数目称做路径长度。
* 树的路径长度：从树根到每一结点的路径长度之和
* 结点的带权的路径长度 = 从该节点到树根之间的路径长度 * 结点上权
* 树的带权的路径长度 = 所有叶子结点的带权路径长度之和


* 算法
    * 1.根据给定的n个权值{w1,w2,...,wn}构成n棵二叉树的集合F={T1,T2,...,Tn}，其中每棵二叉树Ti中只有一个带权为wi根结点，其左右子树均为空。
    * 2.在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
    * 3.在F中删除这两棵树，同时将新得到的二叉树加入F中。
    * 4.重复2和3步骤，直到F只含一棵树为止。这棵树便是赫夫曼树。

* 赫夫曼编码

    * 1、一般地，设需要编码的字符集为{d1,d2,...,dn}，
    * 2、各个字符在电文中出现的次数或频率集合为{w1,w2,...,wn}
    * 3、以d1,d2,...,dn作为叶子结点，
    * 4、以w1,w2,...,wn作为相应叶子结点的权值来构造一棵赫夫曼树。
    * 5、规定赫夫曼树的左分支代表0，右分支代表1，则从根结点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码

